<!doctype html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><title>Lane Flip Sprint</title><style>body,html{margin:0;padding:0;background:#000;color:#fff;font-family:system-ui,-apple-system,sans-serif;-webkit-user-select:none;user-select:none;-webkit-touch-callout:none;-webkit-text-size-adjust:100%}*{-webkit-user-select:none;user-select:none;-webkit-touch-callout:none}#wrap{position:relative;width:100vw;height:100dvh;display:flex;align-items:center;justify-content:center;padding:60px 0 90px;box-sizing:border-box;z-index:1}canvas{background:#111;touch-action:none;border-radius:12px;width:min(92vw,420px);height:auto;max-height:80dvh;z-index:1;pointer-events:auto}#hud{position:fixed;top:calc(env(safe-area-inset-top,0px) + 6px);left:0;right:0;text-align:center;font-size:14px;opacity:.9;z-index:2;pointer-events:none}#controls{position:fixed;left:0;right:0;bottom:calc(env(safe-area-inset-bottom,0px) + 8px);display:flex;justify-content:center;gap:8px;padding:10px 16px;box-sizing:border-box;flex-wrap:wrap;z-index:20;pointer-events:auto}button{padding:10px 14px;border:none;border-radius:10px;background:#222;color:#fff;touch-action:manipulation;-webkit-user-select:none;user-select:none;pointer-events:auto}button:active{transform:scale(.98)}#debugPanel{position:fixed;left:8px;right:8px;bottom:calc(env(safe-area-inset-bottom,0px) + 70px);max-height:30vh;overflow:auto;background:rgba(0,0,0,.7);border:1px solid rgba(255,255,255,.1);padding:8px 10px;font-size:11px;line-height:1.3;z-index:9;display:none}#debugPanel.active{display:block}#debugPanel .row{white-space:pre-wrap;opacity:.9}html.ios #wrap{height:100svh;padding:32px 0 200px}html.ios canvas{max-height:90svh;width:min(96vw,440px)}html.ios #controls{bottom:calc(env(safe-area-inset-bottom,0px) + 2px)}html.ios #debugPanel{bottom:calc(env(safe-area-inset-bottom,0px) + 130px)}html.ios #controls{gap:10px}#startOverlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.85);z-index:10}#startOverlay.hidden{display:none;pointer-events:none}#startOverlay .panel{background:#0b132b;border:1px solid rgba(255,255,255,.1);padding:20px 22px;border-radius:14px;text-align:center;min-width:220px}#startOverlay .title{font-size:18px;margin-bottom:6px}#startOverlay .subtitle{font-size:12px;opacity:.8}#leaderboardPanel{position:fixed;inset:0;background:rgba(0,0,0,.85);display:none;align-items:center;justify-content:center;z-index:11}#leaderboardPanel.active{display:flex}#leaderboardPanel .card{width:min(92vw,420px);max-height:70vh;overflow:auto;background:#0b132b;border:1px solid rgba(255,255,255,.12);border-radius:14px;padding:14px}#leaderboardPanel .head{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}#leaderboardPanel .head h3{margin:0;font-size:16px}#leaderboardPanel label{font-size:12px;opacity:.8}#leaderboardPanel input{width:100%;margin-top:6px;padding:8px 10px;border-radius:10px;border:1px solid #233;background:#111;color:#fff}#leaderboardPanel .actions{display:flex;gap:8px;margin-top:8px}#leaderboardPanel ol{margin:12px 0 0 18px;padding:0}#leaderboardPanel li{margin:6px 0;font-size:13px}</style></head><body><div id="hud">Score: <span id="score">0</span> · Best: <span id="best">0</span></div><div id="wrap"><canvas id="game" width="360" height="640"></canvas></div><div id="controls"><button id="restart">Restart</button> <button id="revive" disabled="disabled">Revive (Rewarded)</button> <button id="audio">Audio: On</button> <button id="leaderboard">Top</button> <button id="debugToggle" style="display:none">HUD: On</button></div><div id="startOverlay"><div class="panel"><div class="title">Tap To Start</div><div class="subtitle">Audio starts after your tap</div></div></div><div id="leaderboardPanel"><div class="card"><div class="head"><h3>Top Scores</h3><button id="lbClose">Close</button></div><label for="nickInput">Nickname</label> <input id="nickInput" maxlength="12" autocomplete="off" placeholder="Your name"><div class="actions"><button id="nickSave">Save</button> <button id="nickReset">Random</button></div><ol id="lbList"></ol></div></div><div id="debugPanel"></div><script>// -----------------------------
    // Web ↔ Native bridge helper
    // -----------------------------
    const bridge = {
      send(type, payload={}) {
        window.parent?.postMessage({ type, payload }, "*");
      },
      on(type, handler) {
        window.addEventListener("message", (e) => {
          if (!e.data || e.data.type !== type) return;
          handler(e.data.payload || {});
        });
      }
    };

    // Native callbacks
    bridge.on("INTERSTITIAL_CLOSED", () => {
      // no-op by default
    });
    bridge.on("REWARDED_GRANTED", (p) => {
      if (p.rewardType === "revive") {
        if (window.__reviveTimer) clearTimeout(window.__reviveTimer);
        dbg("bridge: REWARDED_GRANTED revive");
        doRevive();
      }
    });
    bridge.on("REWARDED_DENIED", () => {
      if (window.__reviveTimer) clearTimeout(window.__reviveTimer);
      dbg("bridge: REWARDED_DENIED");
    });

    // -----------------------------
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    if (isIOS) document.documentElement.classList.add("ios");

    // Game: Lane Flip Sprint
    // Tap to switch lanes and dodge falling blocks.
    // -----------------------------
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const scoreEl = document.getElementById("score");
    const bestEl = document.getElementById("best");
    const restartBtn = document.getElementById("restart");
    const reviveBtn = document.getElementById("revive");
    const audioBtn = document.getElementById("audio");
    const controlsEl = document.getElementById("controls");
    const leaderboardBtn = document.getElementById("leaderboard");
    let lbPanel = document.getElementById("leaderboardPanel");
    let lbClose = document.getElementById("lbClose");
    let lbList = document.getElementById("lbList");
    let nickInput = document.getElementById("nickInput");
    let nickSave = document.getElementById("nickSave");
    let nickReset = document.getElementById("nickReset");
    const debugPanel = document.getElementById("debugPanel");
    const debugToggle = document.getElementById("debugToggle");
    const debugEnabled = new URLSearchParams(window.location.search).has("debug");

    const startOverlay = document.getElementById("startOverlay");

    function dbg(msg) {
      if (!debugEnabled || !debugPanel.classList.contains("active")) return;
      const line = document.createElement("div");
      line.className = "row";
      line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
      debugPanel.appendChild(line);
      debugPanel.scrollTop = debugPanel.scrollHeight;
      if (debugPanel.childNodes.length > 80) {
        debugPanel.removeChild(debugPanel.firstChild);
      }
      console.log(msg);
    }
    if (debugEnabled) {
      debugPanel.classList.add("active");
      if (debugToggle) {
        debugToggle.style.display = "inline-block";
        debugToggle.textContent = "HUD: On";
      }
    }


    function handleInput(e) {
      if (modalOpen) return;
      noteUserGesture();
      if (!running) {
        hideStartOverlay();
        reset();
      }
      player.lane = 1 - player.lane;
      dbg(`input: lane=${player.lane}`);
      if (audioOn) sfxTap();
    }

    function isControlTarget(target) {
      return !!(target && target.closest && target.closest("#controls"));
    }

    function getEventPoint(e) {
      if (e.touches && e.touches[0]) {
        return { x: e.touches[0].clientX, y: e.touches[0].clientY };
      }
      if (e.changedTouches && e.changedTouches[0]) {
        return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
      }
      return { x: e.clientX, y: e.clientY };
    }

    function isControlPoint(e) {
      if (!controlsEl) return false;
      const r = controlsEl.getBoundingClientRect();
      const p = getEventPoint(e);
      return p.x >= r.left && p.x <= r.right && p.y >= r.top && p.y <= r.bottom;
    }

    function onGlobalInput(e) {
      if (modalOpen || isControlTarget(e.target) || isControlPoint(e)) return;
      if (e.cancelable) e.preventDefault();
      const now = performance.now();
      if (now - lastInputAt < 200) return;
      lastInputAt = now;
      handleInput(e);
    }

    function showStartOverlay() {
      if (!startOverlay) return;
      startOverlay.classList.remove("hidden");
      running = false;
    }

    function hideStartOverlay() {
      if (!startOverlay) return;
      startOverlay.classList.add("hidden");
    }

    function ensureLeaderboardPanel() {
      if (lbPanel) return;
      const panel = document.createElement("div");
      panel.id = "leaderboardPanel";
      panel.innerHTML = `
        <div class="card">
          <div class="head">
            <h3>Top Scores</h3>
            <button id="lbClose">Close</button>
          </div>
          <label for="nickInput">Nickname</label>
          <input id="nickInput" maxlength="12" autocomplete="off" placeholder="Your name">
          <div class="actions">
            <button id="nickSave">Save</button>
            <button id="nickReset">Random</button>
          </div>
          <ol id="lbList"></ol>
        </div>
      `;
      document.body.appendChild(panel);
      lbPanel = panel;
      lbClose = panel.querySelector("#lbClose");
      lbList = panel.querySelector("#lbList");
      nickInput = panel.querySelector("#nickInput");
      nickSave = panel.querySelector("#nickSave");
      nickReset = panel.querySelector("#nickReset");
      if (lbClose) lbClose.addEventListener("click", (e) => { e.preventDefault(); closeLeaderboard(); });
      if (nickSave) nickSave.addEventListener("click", (e) => { e.preventDefault(); applyNickname(nickInput.value.trim()); });
      if (nickReset) nickReset.addEventListener("click", (e) => { e.preventDefault(); applyNickname(randomNick()); });
    }

    function openLeaderboard() {
      ensureLeaderboardPanel();
      if (!lbPanel) return;
      dbg("leaderboard: open");
      modalOpen = true;
      pausedByModal = running;
      running = false;
      lbPanel.classList.add("active");
      if (window.FirebaseClient?.getTop) {
        window.FirebaseClient.getTop(10).then(renderLeaderboard).catch(() => renderLeaderboard([]));
      } else {
        renderLeaderboard([]);
      }
    }

    function closeLeaderboard() {
      if (!lbPanel) return;
      lbPanel.classList.remove("active");
      modalOpen = false;
      if (pausedByModal) {
        running = true;
        pausedByModal = false;
        lastMs = performance.now();
      }
    }

    function renderLeaderboard(rows) {
      if (!lbList) return;
      lbList.innerHTML = "";
      if (!rows || rows.length === 0) {
        const li = document.createElement("li");
        li.textContent = "No scores yet";
        lbList.appendChild(li);
        return;
      }
      rows.forEach((r) => {
        const li = document.createElement("li");
        li.textContent = `${r.nick || "Player"} — ${r.score}`;
        lbList.appendChild(li);
      });
    }

    function bridgeAvailable() {
      return !!(window.AndroidBridge || (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.iOSBridge));
    }

    function onReviveRequested() {
      noteUserGesture();
      dbg("revive: requested");
      if (bridgeAvailable()) {
        if (window.__reviveTimer) clearTimeout(window.__reviveTimer);
        window.__reviveTimer = setTimeout(() => {
          dbg("revive: timeout fallback");
          doRevive();
        }, 800);
        bridge.send("REQUEST_REWARDED", { reason: "revive" });
      } else {
        doRevive();
      }
    }

    function onRestartRequested() {
      noteUserGesture();
      reset();
    }

    function applyNickname(nick) {
      if (!nick) return;
      localStorage.setItem("nick", nick);
      if (nickInput) nickInput.value = nick;
      if (window.FirebaseClient?.setNick) window.FirebaseClient.setNick(nick);
    }

    function randomNick() {
      const n = Math.floor(1000 + Math.random() * 9000);
      return `Runner-${n}`;
    }

    // Ensure leaderboard panel exists even if missing in cached HTML.
    ensureLeaderboardPanel();
    if (nickInput && !nickInput.value) {
      const saved = localStorage.getItem("nick") || randomNick();
      applyNickname(saved);
    }

    function onAudioToggle() {
      audioOn = !audioOn;
      audioBtn.textContent = audioOn ? "Audio: On" : "Audio: Off";
      dbg(`audio: ${audioOn ? "on" : "off"}`);
      noteUserGesture();
      else if (audioCtx && audioCtx.state === "running") audioCtx.suspend();
    }

    let viewW = canvas.width;
    let viewH = canvas.height;

    function resizeCanvas() {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const maxW = Math.min(window.innerWidth * 0.96, 440);
      const maxH = window.innerHeight * 0.90;
      const w = Math.max(240, Math.min(maxW, maxH * 0.5625));
      const h = Math.max(426, Math.min(maxH, w / 0.5625));
      viewW = w;
      viewH = h;
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    const lanes = [viewW * 0.33, viewW * 0.67];
    const player = { lane: 0, y: viewH - 90, r: 18 };
    const obstacles = [];

    let running = false;
    let score = 0;
    let best = Number(localStorage.getItem("best") || 0);
    let startMs = 0;
    let dead = false;
    let canRevive = false;
    let invincibleMs = 0;
    let spawnTimer = 0;
    let lastMs = 0;
    let audioOn = true;
    let lastInputAt = 0;
    let lastControlAt = 0;
    let modalOpen = false;
    let pausedByModal = false;

    // -----------------------------
    // Audio (WebAudio)
    // -----------------------------
    let audioCtx = null;
    let musicTimer = 0;
    let musicStep = 0;
    let userGestureSeen = false;
    let audioUnlocked = false;

    function startAudioIfNeeded() {
      if (!audioOn || !userGestureSeen) return false;
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (audioCtx.state === "suspended") {
        audioCtx.resume();
      }
      if (!audioUnlocked) {
        audioUnlocked = true;
        dbg("audio: unlocked");
      }
      return true;
    }

    function noteUserGesture() {
      if (!userGestureSeen) userGestureSeen = true;
      startAudioIfNeeded();
    }

    function tone(freq, dur=0.08, gain=0.05, type="sine") {
      if (!audioCtx) return;
      const t = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = 0.0001;
      o.connect(g);
      g.connect(audioCtx.destination);
      o.start(t);
      g.gain.exponentialRampToValueAtTime(gain, t + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
      o.stop(t + dur + 0.02);
    }

    function sfxTap() {
      tone(420, 0.05, 0.06, "triangle");
    }
    function sfxScore() {
      tone(640, 0.06, 0.05, "sine");
    }
    function sfxHit() {
      tone(140, 0.12, 0.07, "square");
    }

    const musicSeq = [
      196, 0, 220, 0, 196, 0, 246, 0,
      196, 0, 220, 0, 196, 0, 174, 0
    ];

    function updateMusic(dt) {
      if (!audioOn) return;
      if (!audioCtx) return;
      const stepDur = Math.max(0.12, 0.22 - Math.min(score, 30) * 0.003);
      musicTimer -= dt;
      if (musicTimer <= 0) {
        musicTimer = stepDur;
        const f = musicSeq[musicStep % musicSeq.length];
        if (f > 0) tone(f, stepDur * 0.8, 0.03, "sawtooth");
        musicStep++;
      }
    }

    bestEl.textContent = best;

    function reset() {
      resizeCanvas();
      lanes[0] = viewW * 0.33;
      lanes[1] = viewW * 0.67;
      player.y = viewH - 90;
      hideStartOverlay();
      running = true;
      dead = false;
      canRevive = false;
      reviveBtn.disabled = true;
      player.lane = 0;
      score = 0;
      scoreEl.textContent = "0";
      obstacles.length = 0;
      spawnTimer = 0;
      invincibleMs = 0;
      startMs = performance.now();
      lastMs = performance.now();
      bridge.send("GAME_START", {});
      dbg("bridge: GAME_START");
    }


    function submitScoreToCloud(score) {
      if (window.FirebaseClient?.submitScore) {
        window.FirebaseClient.submitScore(score);
      } else {
        (window.__pendingScores = window.__pendingScores || []).push(score);
      }
    }

    function gameOver() {
      if (dead) return;
      dead = true;
      running = false;

      const durationMs = Math.max(0, performance.now() - startMs);
      bridge.send("GAME_OVER", { score, durationMs });
      dbg(`bridge: GAME_OVER score=${score} dur=${Math.floor(durationMs)}ms`);

      canRevive = true;
      reviveBtn.disabled = false;

      bridge.send("REQUEST_INTERSTITIAL", { reason: "game_over" });
      dbg("bridge: REQUEST_INTERSTITIAL");

      submitScoreToCloud(score);
      if (score > best) {
        best = score;
        localStorage.setItem("best", String(best));
        bestEl.textContent = best;
      }
      if (audioOn) sfxHit();
    }

    function doRevive() {
      if (!canRevive) return;
      canRevive = false;
      reviveBtn.disabled = true;
      running = true;
      dead = false;
      invincibleMs = 1500;
      dbg("revive: applied");
      for (let i = obstacles.length - 1; i >= 0; i--) {
        if (obstacles[i].y > player.y - 120) obstacles.splice(i, 1);
      }
    }

    if (startOverlay) {
      startOverlay.addEventListener("pointerdown", (e) => { e.preventDefault(); hideStartOverlay(); noteUserGesture(); reset(); });
      startOverlay.addEventListener("touchstart", (e) => { e.preventDefault(); hideStartOverlay(); noteUserGesture(); reset(); }, { passive: false });
      startOverlay.addEventListener("click", (e) => { e.preventDefault(); hideStartOverlay(); noteUserGesture(); reset(); });
    }

    function toggleHud() {
      if (!debugEnabled) return;
      const active = debugPanel.classList.toggle("active");
      if (debugToggle) debugToggle.textContent = active ? "HUD: On" : "HUD: Off";
    }

    if (leaderboardBtn) {
      leaderboardBtn.addEventListener("pointerdown", (e) => { e.preventDefault(); e.stopPropagation(); openLeaderboard(); });
      leaderboardBtn.addEventListener("pointerup", (e) => { e.preventDefault(); e.stopPropagation(); openLeaderboard(); });
      leaderboardBtn.addEventListener("touchstart", (e) => { e.preventDefault(); e.stopPropagation(); openLeaderboard(); }, { passive: false });
      leaderboardBtn.addEventListener("touchend", (e) => { e.preventDefault(); e.stopPropagation(); openLeaderboard(); }, { passive: false });
      leaderboardBtn.addEventListener("click", (e) => { e.preventDefault(); e.stopPropagation(); openLeaderboard(); });
      leaderboardBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); openLeaderboard(); };
    }
    if (controlsEl) {
      const delegate = (e) => {
        const t = e.target;
        if (t && t.id === "leaderboard") {
          e.preventDefault();
          e.stopPropagation();
          openLeaderboard();
        }
      };
      controlsEl.addEventListener("pointerdown", delegate, true);
      controlsEl.addEventListener("pointerup", delegate, true);
      controlsEl.addEventListener("touchstart", delegate, { passive: false, capture: true });
      controlsEl.addEventListener("touchend", delegate, { passive: false, capture: true });
      controlsEl.addEventListener("click", delegate, true);
    }
    if (lbClose) {
      lbClose.addEventListener("click", (e) => { e.preventDefault(); closeLeaderboard(); });
    }
    if (nickSave) {
      nickSave.addEventListener("click", (e) => { e.preventDefault(); applyNickname(nickInput.value.trim()); });
    }
    if (nickReset) {
      nickReset.addEventListener("click", (e) => { e.preventDefault(); applyNickname(randomNick()); });
    }
    if (nickInput && !nickInput.value) {
      const saved = localStorage.getItem("nick") || randomNick();
      applyNickname(saved);
    }

    function handleControlAction(e) {
      e.preventDefault();
      e.stopPropagation();
      const now = performance.now();
      if (now - lastControlAt < 200) return;
      lastControlAt = now;
      const target = e.target;
      if (!target) return;
      if (target === reviveBtn) onReviveRequested();
      else if (target === restartBtn) onRestartRequested();
      else if (target === audioBtn) onAudioToggle();
      else if (target === leaderboardBtn) openLeaderboard();
      else if (target === debugToggle) toggleHud();
    }

    // Single-action handlers to avoid double-fire in WebView
    reviveBtn.addEventListener("pointerdown", handleControlAction);
    reviveBtn.addEventListener("touchstart", handleControlAction, { passive: false });
    reviveBtn.addEventListener("click", handleControlAction);
    restartBtn.addEventListener("pointerdown", handleControlAction);
    restartBtn.addEventListener("touchstart", handleControlAction, { passive: false });
    restartBtn.addEventListener("click", handleControlAction);
    audioBtn.addEventListener("pointerdown", handleControlAction);
    audioBtn.addEventListener("touchstart", handleControlAction, { passive: false });
    audioBtn.addEventListener("click", handleControlAction);
    leaderboardBtn.addEventListener("pointerdown", handleControlAction);
    leaderboardBtn.addEventListener("touchstart", handleControlAction, { passive: false });
    leaderboardBtn.addEventListener("click", handleControlAction);
    if (debugToggle) {
      debugToggle.addEventListener("pointerdown", handleControlAction);
      debugToggle.addEventListener("touchstart", handleControlAction, { passive: false });
      debugToggle.addEventListener("click", handleControlAction);
    }

    canvas.addEventListener("pointerdown", (e) => {
      if (modalOpen) return;
      e.preventDefault();
      handleInput(e);
    });
    canvas.addEventListener("touchstart", (e) => {
      if (modalOpen) return;
      e.preventDefault();
      handleInput(e);
    }, { passive: false });
    canvas.addEventListener("mousedown", (e) => {
      if (modalOpen) return;
      e.preventDefault();
      handleInput(e);
    });
    canvas.addEventListener("click", (e) => {
      if (modalOpen) return;
      e.preventDefault();
      handleInput(e);
    });

    // Fallback for WebView touch routing issues
    document.addEventListener("pointerdown", onGlobalInput, true);
    document.addEventListener("touchstart", onGlobalInput, { passive: false, capture: true });
    document.addEventListener("mousedown", onGlobalInput, true);
    document.addEventListener("click", onGlobalInput, true);

    function spawnObstacle() {
      const lane = Math.random() < 0.5 ? 0 : 1;
      obstacles.push({
        lane,
        y: -30,
        w: 80,
        h: 26
      });
    }

    function update(dt) {
      if (!running) return;
      updateMusic(dt);

            spawnTimer -= dt;
            if (spawnTimer <= 0) {
              const base = Math.max(0.45, 0.75 - Math.min(score, 40) * 0.008);
              spawnTimer = base;
              spawnObstacle();
            }

            const speed = 260 + score * 12;
            for (let i = obstacles.length - 1; i >= 0; i--) {
              const o = obstacles[i];
              o.y += speed * dt;

        if (o.y - o.h / 2 > viewH + 10) {
          obstacles.splice(i, 1);
          score += 1;
          scoreEl.textContent = String(score);
          if (audioOn) sfxScore();
          continue;
        }

        if (o.lane === player.lane && invincibleMs <= 0) {
          const hitY = Math.abs(o.y - player.y) < (o.h / 2 + player.r);
          if (hitY) gameOver();
        }
      }

      if (invincibleMs > 0) invincibleMs -= dt * 1000;
    }

    function draw() {
      ctx.clearRect(0, 0, viewW, viewH);
            // dynamic background
            const t = performance.now() * 0.001;
            const g = ctx.createLinearGradient(0, 0, 0, viewH);
            g.addColorStop(0, "#0b132b");
            g.addColorStop(1, "#1b263b");
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, viewW, viewH);

            // speed streaks
            ctx.strokeStyle = "rgba(255,255,255,0.08)";
            ctx.lineWidth = 2;
            for (let i = 0; i < 6; i++) {
              const x = (i + 1) * viewW / 7;
              const y = (t * 140 + i * 120) % viewH;
              ctx.beginPath();
              ctx.moveTo(x, y);
              ctx.lineTo(x, y + 80);
              ctx.stroke();
            }

            ctx.strokeStyle = "#222";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(viewW / 2, 0);
            ctx.lineTo(viewW / 2, viewH);
            ctx.stroke();

            for (const o of obstacles) {
              ctx.fillStyle = "#e74c3c";
              const x = lanes[o.lane] - o.w / 2;
              const y = o.y - o.h / 2;
              ctx.fillRect(x, y, o.w, o.h);
            }

            // player glow
            ctx.fillStyle = invincibleMs > 0 ? "#f1c40f" : "#4aa3ff";
            ctx.beginPath();
            ctx.arc(lanes[player.lane], player.y, player.r, 0, Math.PI * 2);
            ctx.fill();

            // vignette
            const vg = ctx.createRadialGradient(viewW/2, viewH/2, 50, viewW/2, viewH/2, viewW);
            vg.addColorStop(0, "rgba(0,0,0,0)");
            vg.addColorStop(1, "rgba(0,0,0,0.45)");
            ctx.fillStyle = vg;
            ctx.fillRect(0, 0, viewW, viewH);

            if (dead) {
              ctx.fillStyle = "#fff";
              ctx.font = "20px system-ui, sans-serif";
        ctx.fillText("Game Over", viewW / 2 - 55, viewH / 2);
        ctx.font = "14px system-ui, sans-serif";
        ctx.fillText("Tap Restart or Revive", viewW / 2 - 70, viewH / 2 + 24);
      }
    }

    function loop(ms) {
      const dt = Math.min(0.032, (ms - lastMs) / 1000);
      lastMs = ms;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }
    window.addEventListener("resize", () => { resizeCanvas(); lanes[0] = viewW * 0.33; lanes[1] = viewW * 0.67; player.y = viewH - 90; });
    resizeCanvas();
    requestAnimationFrame(loop);

    reset();
    showStartOverlay();
    document.addEventListener('contextmenu', (e) => e.preventDefault());
    document.addEventListener('selectstart', (e) => e.preventDefault());</script><script type="module">import{initializeApp}from"https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";import{getAuth,signInAnonymously,onAuthStateChanged}from"https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";import{getFirestore,doc,setDoc,serverTimestamp,collection,query,orderBy,limit,getDocs}from"https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";const firebaseConfig={apiKey:"AIzaSyAP64ztM7l4rMaODH3OXhq6cmDcKq-jDno",authDomain:"laneflipsprint.firebaseapp.com",projectId:"laneflipsprint",storageBucket:"laneflipsprint.firebasestorage.app",messagingSenderId:"122169792197",appId:"1:122169792197:web:41b87a533ca68cd8bd42ac",measurementId:"G-T26CQ355X0"},app=initializeApp(firebaseConfig),auth=getAuth(app),db=getFirestore(app),state={uid:null,nick:localStorage.getItem("nick")||null,ready:!1};async function ensureNick(e){state.nick||(state.nick=`Runner-${e.slice(0,4)}`,localStorage.setItem("nick",state.nick)),await setDoc(doc(db,"players",e),{nick:state.nick,updatedAt:serverTimestamp()},{merge:!0})}async function submitScore(e){if(!state.uid)return;const t=localStorage.getItem("nick")||state.nick||"Player",a={score:e,nick:t,updatedAt:serverTimestamp()};try{await setDoc(doc(db,"leaderboard",state.uid),a,{merge:!0})}catch(e){}try{await setDoc(doc(db,"players",state.uid),{bestScore:e,nick:t,updatedAt:serverTimestamp()},{merge:!0})}catch(e){}}async function getTop(e){const t=query(collection(db,"leaderboard"),orderBy("score","desc"),limit(e));return(await getDocs(t)).docs.map(e=>e.data())}async function setNick(e){state.nick=e,localStorage.setItem("nick",e),state.uid&&(await setDoc(doc(db,"players",state.uid),{nick:e,updatedAt:serverTimestamp()},{merge:!0}),await setDoc(doc(db,"leaderboard",state.uid),{nick:e,updatedAt:serverTimestamp()},{merge:!0}))}window.FirebaseClient={submitScore:submitScore,getTop:getTop,setNick:setNick,ready:!1},signInAnonymously(auth).catch(()=>{}),onAuthStateChanged(auth,async e=>{if(e&&(state.uid=e.uid,await ensureNick(e.uid),window.FirebaseClient.ready=!0,window.__pendingScores&&window.__pendingScores.length)){const e=window.__pendingScores.slice();window.__pendingScores.length=0,e.forEach(e=>submitScore(e))}})</script></body></html>